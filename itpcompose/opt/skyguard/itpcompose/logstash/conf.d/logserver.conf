input {
    kafka {
        bootstrap_servers => "172.238.238.237:9092"
        topics => "seg"
        type => "seg-input"
        codec => "json"
    }
    kafka {
        bootstrap_servers => "172.238.238.237:9092"
        topics => "network"
        type => "network-input"
        codec => "json"
    }
    kafka {
        bootstrap_servers => "172.238.238.237:9092"
        topics => "swg"
        type => "swg-input"
        codec => "json"
    }
    kafka {
        bootstrap_servers => "172.238.238.237:9092"
        topics => "incidentlog"
        type => "incidentlog-input"
        codec => "json"
    }
    kafka {
        bootstrap_servers => "172.238.238.237:9092"
        topics => "mta"
        type => "mta-input"
        codec => "json"
    }
    kafka {
        bootstrap_servers => "172.238.238.237:9092"
        topics => "dns"
        type => "dns-input"
        codec => "json"
    }
    kafka {
        bootstrap_servers => "172.238.238.237:9092"
        topics => "ssl"
        type => "ssl-input"
        codec => "json"
    }
    kafka {
        bootstrap_servers => "172.238.238.237:9092"
        topics => "aclog-action"
        type => "aclog-action-input"
        codec => "json"
    }
    kafka {
        bootstrap_servers => "172.238.238.237:9092"
        topics => "aclog-httptype_flux"
        type => "aclog-httptype_flux-input"
        codec => "json"
    }
    kafka {
        bootstrap_servers => "172.238.238.237:9092"
        topics => "endpoint"
        type => "endpoint-input"
        codec => "json"
    }
}

#input {
#    redis {
#        data_type => "list"
#        key => "network"
#        host => "172.238.238.238"
#        port => 6379
#        type => "network-input"
#        threads => 8
#    }
#    redis {
#        data_type => "list"
#        key => "swg"
#        host => "172.238.238.238"
#        port => 6379
#        type => "swg-input"
#        threads => 8
#    }
#    redis {
#        data_type => "list"
#        key => "incidentlog"
#        host => "172.238.238.238"
#        port => 6379
#        type => "incidentlog-input"
#        threads => 4
#    }
#    redis {
#        data_type => "list"
#        key => "mta"
#        host => "172.238.238.238"
#        port => 6379
#        type => "mta-input"
#        threads => 4
#    }
#    redis {
#        data_type => "list"
#        key => "dns"
#        host => "172.238.238.238"
#        port => 6379
#        type => "dns-input"
#        threads => 8
#    }
#    redis {
#        data_type => "list"
#        key => "ssl"
#        host => "172.238.238.238"
#        port => 6379
#        type => "ssl-input"
#        threads => 2
#    }
#    redis {
#        data_type => "list"
#        key => "aclog-action"
#        host => "172.238.238.238"
#        port => 6379
#        type => "aclog-action-input"
#        threads => 4
#    }
#    redis {
#        data_type => "list"
#        key => "aclog-httptype_flux"
#        host => "172.238.238.238"
#        port => 6379
#        type => "aclog-httptype_flux-input"
#        threads => 4
#    }
#    redis {
#        data_type => "list"
#        key => "endpoint"
#        host => "172.238.238.238"
#        port => 6379
#        type => "endpoint-input"
#        threads => 4
#    }
#}

filter {
    ruby {
        code => "event.set('insert_ts', Time.now.utc)"
    }

    if [type] == "seg-input" {
        json {
            source => "message"
            remove_field => ["message"]
        }
        date {
            match => ["detectDateTime", "ISO8601"]
        }
        ruby {
            code => "
                event.set('[@metadata][index_day]', event.get('@timestamp').time.localtime.strftime('%Y.%m.%d'))
            "
        }
        # http://confluence.skyguardmis.com/pages/viewpage.action?pageId=26084859
        # "direction" : 1,//1外到外 2内到内  3内到外 4外到内
        if [direction] == 2 or [direction] == 3 {
            mutate { add_field => { "[@metadata][query_email]" => "%{mailFrom}" } }
        }
        else if [direction] == 4 {
            mutate { add_field => { "[@metadata][query_email]" => "%{mailTo}" } }
        }
        else {
            # drop {}
            mutate { add_field => { "[@metadata][query_email]" => "%{mailFrom}" } }
        }
        if [@metadata][query_email] {
            elasticsearch {
                hosts => ["elasticsearch"]
                index => "entry_info"
                query => "mail.keyword:%{[@metadata][query_email]}"
                fields => { "uuid" => "userId" }
                add_field => { "use_userId" => 1 }
                enable_sort => false
            }
        }
        if ![userId] {
            mutate {
                add_field => { "userId" => "%{[@metadata][query_email]}" }
                add_field => { "use_userId" => 0 }
            }
        }
    }
    if [type] == "ssl-input" {
        json {
            source => "message"
            remove_field => ["message"]
        }
        mutate {
            rename => {
                "id.resp_p" => "destinationPort"
                "id.resp_h" => "destinationIp"
                "id.orig_h" => "sourceIp"
                "id.orig_p" => "sourcePort"
            }
        }
        date {
            match => ["ts", "yyyy-MM-dd HH:mm:ss", "UNIX"]
            target => "@timestamp"
        }
        ruby {
            code => "
                event.set('[@metadata][index_day]', event.get('@timestamp').time.localtime.strftime('%Y.%m.%d'))
            "
        }
        ruby {
            init => 'require "redis"; require "json"; $rc = Redis.new(host: "172.238.238.238", port: 6379, db: 2)'
            code => '
                v = $rc.hgetall("tag:" + event.get("sourceIp"))
                if v.has_key?("userid")
                    event.set("userId", v["userid"] )
                    event.set("use_userId", 1 )
                else
                    event.set("userId", event.get("sourceIp"))
                    event.set("use_userId", 0 )
                end
                if v.has_key?("os_tag")
                    event.set("os_tag", v["os_tag"] )
                end
                if v.has_key?("srv_tag")
                    event.set("srv_tag", JSON.parse(v["srv_tag"]) )
                end
            '
        }
        if [destinationIp] {
            geoip {
                source => "destinationIp"
            }
            geoip {
                source => "destinationIp"
                default_database_type => "ASN"
            }
        }
        translate {
            field => "host"
            destination => "deviceID"
            #dictionary => ["172.22.113.103","de1e9872-451c-4827-9dae-1baf921c86f2"]
            dictionary_path => "/opt/ucss_mapping.json"
        }
    }
    if [type] == "dns-input" {
        json {
            source => "message"
            remove_field => ["message"]
        }
        if [id.orig_h] {
            grok {
                match =>  ["id.orig_h", "%{IPV4:[@metadata][ipv4_sourceIp]}"]
            }
            if [@metadata][ipv4_sourceIp] {}
            else {
                drop {}
            }
        }
            date {
                match => ["ts", "yyyy-MM-dd HH:mm:ss", "UNIX"]
                target => "@timestamp"
            }
            ruby {
                code => "
                    event.set('[@metadata][index_day]', event.get('@timestamp').time.localtime.strftime('%Y.%m.%d'))
                "
            }
            mutate {
                rename => {
                    "id.resp_p" => "destinationPort"
                    "id.resp_h" => "destinationIp"
                    "id.orig_h" => "sourceIp"
                    "id.orig_p" => "sourcePort"
                }
            }
            ruby {
                init => 'require "redis"; require "json"; $rc = Redis.new(host: "172.238.238.238", port: 6379, db: 2)'
                code => '
                    v = $rc.hgetall("tag:" + event.get("sourceIp"))
                    if v.has_key?("userid")
                        event.set("userId", v["userid"] )
                        event.set("use_userId", 1 )
                    else
                        event.set("userId", event.get("sourceIp"))
                        event.set("use_userId", 0 )
                    end
                    if v.has_key?("os_tag")
                        event.set("os_tag", v["os_tag"] )
                    end
                    if v.has_key?("srv_tag")
                        event.set("srv_tag", JSON.parse(v["srv_tag"]) )
                    end
                '
            }
            translate {
                field => "host"
                destination => "deviceID"
                #dictionary => ["172.22.113.103","de1e9872-451c-4827-9dae-1baf921c86f2"]
                dictionary_path => "/opt/ucss_mapping.json"
            }
    }
    if [type] == "network-input" {
        json {
              source => "message"
              remove_field => ["message", "offset", "beat", "input_type", "@version"]
        }
        if [id.orig_h] {
            grok {
                match =>  ["id.orig_h", "%{IPV4:[@metadata][ipv4_sourceIp]}"]
            }
            if [@metadata][ipv4_sourceIp] {}
            else {
                drop {}
            }
        }
            date {
                match => ["ts", "yyyy-MM-dd HH:mm:ss", "UNIX"]
                target => "@timestamp"
            }
            ruby {
                code => "
                    event.set('[@metadata][index_day]', event.get('@timestamp').time.localtime.strftime('%Y.%m.%d'))
                "
            }
            mutate {
                rename => {
                    "id.resp_p" => "resp_p"
                    "id.resp_h" => "resp_h"
                    "id.orig_h" => "orig_h"
                    "id.orig_p" => "orig_p"
                }
                add_field => {
                    "sourceIp" => "%{orig_h}"
                    "destinationIp" => "%{resp_h}"
                    "sendBytes" => "%{orig_ip_bytes}"
                }
            }

            if ![local_orig] and [local_resp] {
                ruby {
                    init => 'require "redis"; require "json"; $rc = Redis.new(host: "172.238.238.238", port: 6379, db: 2)'
                    code => '
                        v = $rc.hgetall("tag:" + event.get("resp_h"))
                        if v.has_key?("userid")
                            event.set("userId", v["userid"] )
                            event.set("use_userId", 1 )
                        else
                            event.set("userId", event.get("destinationIp"))
                            event.set("use_userId", 0 )
                        end
                        if v.has_key?("os_tag")
                            event.set("os_tag", v["os_tag"] )
                        end
                        if v.has_key?("srv_tag")
                            event.set("srv_tag", JSON.parse(v["srv_tag"]) )
                        end
                    '
                }
            } else {
                ruby {
                    init => 'require "redis"; require "json"; $rc = Redis.new(host: "172.238.238.238", port: 6379, db: 2)'
                    code => '
                        v = $rc.hgetall("tag:" + event.get("orig_h"))
                        if v.has_key?("userid")
                            event.set("userId", v["userid"] )
                            event.set("use_userId", 1 )
                        else
                            event.set("userId", event.get("sourceIp"))
                            event.set("use_userId", 0 )
                        end
                        if v.has_key?("os_tag")
                            event.set("os_tag", v["os_tag"] )
                        end
                        if v.has_key?("srv_tag")
                            event.set("srv_tag", JSON.parse(v["srv_tag"]) )
                        end
                    '
                }
            }

            translate {
                field => "host"
                destination => "deviceID"
                #dictionary => ["172.22.113.103","de1e9872-451c-4827-9dae-1baf921c86f2"]
                dictionary_path => "/opt/ucss_mapping.json"
            }
    }

    if [type] == "mta-input" {
        json {
            source => "message"
            remove_field => ["message", "deviceId"]
        }
        translate {
            field => "host"
            destination => "deviceID"
            #dictionary => ["172.22.113.103","de1e9872-451c-4827-9dae-1baf921c86f2"]
            dictionary_path => "/opt/ucss_mapping.json"
        }
        date {
            match => ["timestamp", "MMM dd HH:mm:ss", "yyyy-MM-dd HH:mm:ss"]
            target => "@timestamp"
        }
        ruby {
            code => "
                event.set('[@metadata][index_day]', event.get('@timestamp').time.localtime.strftime('%Y.%m.%d'))
            "
        }
    }

    if [type] == "swg-input" {
        json {
            source => "message"
            remove_field => ["message", "deviceId"]
        }
        grok {
            match =>  ["fullUrl", "%{URIPROTO:uriProto}://(?:%{USER:user}(?::[^@]*)?@)?(?:%{URIHOST:uriDomain})?(?:%{URIPATHPARAM:uriParam})?" ]
            remove_field => ["uriParam"]
        }
        if [sourceIp] {
            ruby {
                init => 'require "redis"; require "json"; $rc = Redis.new(host: "172.238.238.238", port: 6379, db: 2)'
                code => '
                    v = $rc.hgetall("tag:" + event.get("sourceIp"))
                    if v.has_key?("userid")
                        event.set("userId", v["userid"] )
                        event.set("use_userId", 1 )
                    else
                        event.set("userId", event.get("sourceIp"))
                        event.set("use_userId", 0 )
                    end
                    if v.has_key?("os_tag")
                        event.set("os_tag", v["os_tag"] )
                    end
                    if v.has_key?("srv_tag")
                        event.set("srv_tag", JSON.parse(v["srv_tag"]) )
                    end
                '
            }
        }
        if [destinationIp] {
            geoip {
                source => "destinationIp"
            }
            geoip {
                source => "destinationIp"
                default_database_type => "ASN"
            }
        }
        translate {
            field => "host"
            destination => "deviceID"
            #dictionary => ["172.22.113.103","de1e9872-451c-4827-9dae-1baf921c86f2"]
            dictionary_path => "/opt/ucss_mapping.json"
        }
        # date {
        #     match => ["timestamp", "yyyy-MM-dd HH:mm:ss"]
        #     target => "@timestamp"
        # }
        date {
            match => ["detectDateTime", "ISO8601"]
        }
        ruby {
            code => "
                event.set('[@metadata][index_day]', event.get('@timestamp').time.localtime.strftime('%Y.%m.%d'))
            "
        }
        if [httpReqHdrBytes] and [httpReqBodyBytes] {
            ruby {            
                code => "event.set('sendBytes', event.get('httpReqHdrBytes') + event.get('httpReqBodyBytes'))"
            }    
        }
    }

    if [type] == "incidentlog-input" {
        translate {
            field => "host"
            destination => "deviceID"
            #dictionary => ["172.22.113.103","de1e9872-451c-4827-9dae-1baf921c86f2"]
            dictionary_path => "/opt/ucss_mapping.json"
        }
        date {
            match => ["timestamp", "MMM dd HH:mm:ss", "yyyy-MM-dd HH:mm:ss"]
            target => "@timestamp"
        }
        ruby {
            code => "
                event.set('[@metadata][index_day]', event.get('@timestamp').time.localtime.strftime('%Y.%m.%d'))
            "
        }
        ruby {
            init => "
                # encoding: UTF-8
                require 'json'
                $source_key_map = Hash.new('source')
                $source_key_map = {'ipAddress' => 'sourceIp', 'username' => 'sourceLogonName', 'emailAddress' => 'sourceMail', 'userUuid' => 'sourceUuid', 'domain' => 'sourceDomain'}
                $dest_key_map = Hash.new('dest')
                $dest_key_map = {'ipAddress' => 'destinationIps', 'emailAddress' => 'destinationMails', 'domain' => 'destinationDomains', 'cloudAppID' => 'cloudAppId'}
                def parse_incident(incident)
                    res_str = '{}'
                    res = JSON.parse(res_str)

                    inct = JSON.parse(incident)
                    inct['matchedPolicies'].each do |policy|
                        if !res.key?('policyNames')
                            res['policyNames'] = policy['name']
                        else
                            res['policyNames'] << ',' << policy['name']
                        end
                        if !res.key?('policyUuids')
                            res['policyUuids'] = policy['uuid']
                        else
                            res['policyUuids'] << ',' << policy['uuid']
                        end
                    end
                    res['transactionSize'] = inct['incidentInfo']['totalSize']
                    res['incidentType'] = inct['incidentInfo']['type']
                    res['incidentId'] = inct['incidentInfo']['incidentId']
                    res['channel'] = inct['incidentInfo']['channelType']
                    res['channelType'] = inct['incidentInfo']['channelType']
                    res['sourceOrig'] = inct['networkInfo']['source']
                    res['destinationsOrig'] = inct['networkInfo']['destinations']
                    # watermark channel - 2220
                    if (inct['incidentInfo']['channelType'] == 22 and inct['actionTaken']['agentAction'] == 10)
                        res['channelType'] = 2220
                    end
                    source = inct['networkInfo']['source']['incidentUser']
                    $source_key_map.keys.each do |key|
                        if source.key?(key)
                            res[$source_key_map[key]] = source[key]
                        end
                    end
                    if inct['networkInfo'].key?('destinations')
                    	inct['networkInfo']['destinations'].each do |dest|
                    	    dest_user = dest['incidentUser']
                    	    # application incident
                    	    if (res['channelType'] == 22)
                    	        res['channelType'] = 2200 + dest_user['appOperationType']
                    	    end
                    	    if dest_user.key?('urlClassification')
                    	        res['categoryTypes'] = dest_user['urlClassification'].split(' ').map { |s| s.to_i }
                    	    end
                    	    $dest_key_map.keys.each do |key|
                    	        if dest_user.key?(key)
                    	            if !res.key?($dest_key_map[key])
                    	               res[$dest_key_map[key]] = dest_user[key]
                    	            else
                    	               res[$dest_key_map[key]] << ',' << dest_user[key]
                    	            end
                    	        end
                    	    end
                    	end
                    end
                return res
                end
            "
            code => "
                res = parse_incident(event.get('message'))
                res.keys.each do |key|
                    event.set(key, res[key])
                end
            "
            remove_field => ["message"]
        }
        if [sourceIp] {
            ruby {
                init => 'require "redis"; require "json"; $rc = Redis.new(host: "172.238.238.238", port: 6379, db: 2)'
                code => '
                    v = $rc.hgetall("tag:" + event.get("sourceIp"))
                    if v.has_key?("userid")
                        event.set("userId", v["userid"] )
                        event.set("use_userId", 1 )
                    else
                        event.set("userId", event.get("sourceIp"))
                        event.set("use_userId", 0 )
                    end
                    if v.has_key?("os_tag")
                        event.set("os_tag", v["os_tag"] )
                    end
                    if v.has_key?("srv_tag")
                        event.set("srv_tag", JSON.parse(v["srv_tag"]) )
                    end
                '
            }
        }
   }

    if [type] =~ "^aclog.*-input$"  {
        mutate {
            rename => {
                "host_ip" => "sourceIp"
            }
        }
        date {
            match => ["record_time", "MMM dd HH:mm:ss", "yyyy-MM-dd HH:mm:ss"]
            target => "@timestamp"
        }
        ruby {
            code => "
                event.set('[@metadata][index_day]', event.get('@timestamp').time.localtime.strftime('%Y.%m.%d'))
            "
        }
        if [type] == "aclog-httptype_flux-input" {
            if [http_type] == "HTTPS" {
                mutate {
                    add_field => {
                        "channelType" => 2
                        "method" => "HTTPS"
                    }
                }
            }
            if [http_type] in ["HTTP-POST", "HTTP文件上传"] {
                mutate {
                    add_field => {
                        "channelType" => 1
                        "method" => "POST"
                    }
                }
            }
            if [http_type] in ["HTTP-GET", "HTTP文件下载"] {
                mutate {
                    add_field => {
                        "channelType" => 1
                        "method" => "GET"
                    }
                }
            }

            mutate {
                add_field => {
                    "httpReqHdrBytes" => 0
                    "httpReqBodyBytes" => "%{up_flux}"
                    "sendBytes" => "%{up_flux}"
                    "httpRspHdrBytes" => 0
                    "httpRspBodyBytes" => "%{down_flux}"
                }
            }

        }

        if [type] == "aclog-action-input" {
            mutate {
                add_field => {
                    "destinationIp" => "%{dst_ip}"
                }
            }

            if [net_action] == "发现病毒" {
                mutate {
                    add_field => {
                        "isSecure" => false
                    }
                }
            } else {
                mutate {
                    add_field => {
                        "isSecure" => true
                    }
                }
            }

            if [result][filename] and [result][filesize] {
                ruby {
                    code => '
                        filename = event.get("result")["filename"]
                        filesize = event.get("result")["filesize"]
                        array = []
                        obj = {}
                        obj["filename"]=filename
                        obj["filesize"]=filesize
                        array[0] = obj
                        event.set("cae_attachments", array)
                    '
                }

            }
            if [result][host] {
                mutate { add_field => { "uriDomain" => "%{[result][host]}" } }
            }
            if [result][url] {
                mutate { add_field => { "fullUrl" => "%{[result][url]}" } }
                grok {
                    match => ["fullUrl", "%{URIPROTO:uriProto}://(?:%{USER:user}(?::[^@]*)?@)?(?:%{URIHOST:uriDomain})?(?:%{URIPATHPARAM:uriParam})?" ]
                    remove_field => ["uriParam"]
                }
            }

        }

#        if [serv] == "邮件" {
#            mutate {
#                add_field => { "channelType" => 4 }
#            }
#        }

        if [result][urltype] {
            translate {
                field => "[result][urltype]"
                destination => "categoryTypes"
                dictionary => [
                    "3868594932",   [3329],
                    "672668640",    [770],
                    "3684937723",   [770],
                    "2750665689",   [771],
                    "765960353",    [1029],
                    "4221908796",   [1537],
                    "1615559819",   [1538],
                    #"",    "1540",
                    #"",    "3841",
                    #"",    "3842",
                    #"",    "3843",
                    "94582972",     [3844],
                    "2293175531",   [3844],
                    "3361086917",   [1293]
                ]
            }
            if ![categoryTypes] {
                ruby {
                    code => '
                        result = event.get("result")
                        event.set("categoryTypes", [result["urltype"].to_i])
                    '
                }
            }
        }
        ruby {
            init => 'require "redis"; require "json"; $rc = Redis.new(host: "172.238.238.238", port: 6379, db: 2)'
            code => '
                v = $rc.hgetall("tag:" + event.get("sourceIp"))
                if v.has_key?("userid")
                    event.set("userId", v["userid"] )
                    event.set("use_userId", 1 )
                else
                    event.set("userId", event.get("sourceIp"))
                    event.set("use_userId", 0 )
                end
                if v.has_key?("os_tag")
                    event.set("os_tag", v["os_tag"] )
                end
                if v.has_key?("srv_tag")
                    event.set("srv_tag", JSON.parse(v["srv_tag"]) )
                end
            '
        }
    }

    if [type] == "endpoint-input"  {
        if [event_type] == "ENDPOINT_SYSTEM_LOG" {
            grok {
                # there is "_" in some logsource name, but original SYSLOGHOST not match this.
                # define our SYSLOGHOST in grok_pattern.txt.
                patterns_dir => ["/etc/logstash/grok_pattern"]
                match => {
                    "message" => ['(?:%{SYSLOGTIMESTAMP:systemlog_timestamp}|%{TIMESTAMP_ISO8601:timestamp8601}) (?:%{SYSLOGFACILITY} )?%{SYSLOGHOST:logsource}+(?: %{PROG:program}(?:\[%{NONNEGINT:pid}\])?:|) %{GREEDYDATA:message}']
                }
                overwrite => ["message"]
            }

            ruby {
                code => '
                    if event.get("program").nil? and not event.get("systemlog_timestamp").nil?
                        msg = event.get("message")
                        colon_pos = msg.index(":")
                        if colon_pos != nil
                            event.set("program", msg[0, colon_pos])
                            event.set("message", msg[(colon_pos + 2)..-1])
                        end
                    end
                '
            }
            date {
                match => ["systemlog_timestamp", "MMM dd HH:mm:ss"]
                target => "@timestamp"
            }
            ruby {
                code => "
                    event.set('[@metadata][index_day]', event.get('@timestamp').time.localtime.strftime('%Y.%m.%d'))
                "
            }
        }
        else {
            json {
                source => "message"
                remove_field => ["message", "deviceId"]
            }
            date {
                match => ["timestamp", "UNIX"]
                    target => "@timestamp"
            }
            if [event_type] == "PROCESS_RESOURCE_USAGE_KERNEL_NETWORK" {
                if [event] and [event][timestamp_begin] {
                    date {
                        match => ["[event][timestamp_begin]", "UNIX"]
                            target => "@timestamp"
                    }
                }
            }
            else if [event_type] in ["PROCESS_RESOURCE_USAGE_KERNEL_REG_QUERY", "PROCESS_RESOURCE_USAGE_KERNEL_OPEN", "PROCESS_RESOURCE_USAGE_KERNEL_DELETE"] {
                if [event] and [event][0] {
                    date {
                        match => ["[event][0][timestamp_begin]", "UNIX"]
                            target => "@timestamp"
                    }
                }
            }
            ruby {
                code => "
                    event.set('[@metadata][index_day]', event.get('@timestamp').time.localtime.strftime('%Y.%m.%d'))
                "
            }
        }

        if [codesign_verify] {
          mutate {
            convert => {
              "codesign_verify" => "boolean"
            }
          }
        }

        if [sourceIp] {
            ruby {
                init => 'require "redis"; require "json"; $rc = Redis.new(host: "172.238.238.238", port: 6379, db: 2)'
                code => '
                    v = $rc.hgetall("tag:" + event.get("sourceIp"))
                    if v.has_key?("userid")
                        event.set("userId", v["userid"] )
                        event.set("use_userId", 1 )
                    else
                        event.set("userId", event.get("sourceIp"))
                        event.set("use_userId", 0 )
                    end
                    if v.has_key?("srv_tag")
                        event.set("srv_tag", JSON.parse(v["srv_tag"]) )
                    end
                '
            }
        }
        translate {
            field => "host"
            destination => "deviceID"
            #dictionary => ["172.22.113.103","de1e9872-451c-4827-9dae-1baf921c86f2"]
            dictionary_path => "/opt/ucss_mapping.json"
        }
    }
}

output {
    if [type] == "network-input" {
        #stdout { codec => rubydebug }
        elasticsearch { hosts => ["172.238.238.239:9200"]
                        manage_template => true
                        template_name => "network"
                        #template => "/home/hdu/project/docker-compose/mapping/network_mapping.json.bak"
                        template => "/opt/mapping/network_mapping.json"
                        template_overwrite => true
                        index => "network-%{[@metadata][index_day]}"
                        document_type => "_doc"
                        user => logstash
                        password => logstash
                      }
    }
    else if [type] == "dns-input" {
        elasticsearch { hosts => ["172.238.238.239:9200"]
                        manage_template => true
                        template => "/opt/mapping/dns_mapping.json"
                        template_name => "dns"
                        template_overwrite => true
                        index => "dns-%{[@metadata][index_day]}"
                        document_type => "_doc"
                        user => logstash
                        password => logstash
                      }
    }
    else if [type] == "swg-input" {
        #stdout { codec => rubydebug }
        elasticsearch { hosts => ["172.238.238.239:9200"]
                        manage_template => true
                        template => "/opt/mapping/swg_mapping.json"
                        template_name => "swg"
                        template_overwrite => true
                        index => "swg-%{[@metadata][index_day]}"
                        document_type => "_doc"
                        user => logstash
                        password => logstash
                      }
    }
    else if [type] == "incidentlog-input" {
        #stdout { codec => rubydebug }
        elasticsearch { hosts => ["172.238.238.239:9200"]
                        manage_template => true
                        template => "/opt/mapping/incidentlog_mapping.json"
                        template_name => "incidentlog"
                        template_overwrite => true
                        index => "incidentlog-%{[@metadata][index_day]}"
                        document_type => "_doc"
                        user => logstash
                        password => logstash
                      }
    }
    else if [type] == "ssl-input" {
        elasticsearch { hosts => ["172.238.238.239:9200"]
                        manage_template => true
                        template => "/opt/mapping/ssl_mapping.json"
                        template_name => "ssl"
                        template_overwrite => true
                        index => "ssl-%{[@metadata][index_day]}"
                        document_type => "_doc"
                        user => logstash
                        password => logstash
                      }
    }
    else if [type] =~ "^aclog.*-input$"  {
        elasticsearch { hosts => ["172.238.238.239:9200"]
                        manage_template => true
                        template => "/opt/mapping/aclog_mapping.json"
                        template_name => "aclog"
                        template_overwrite => true
                        index => "aclog-%{[@metadata][index_day]}"
                        document_type => "_doc"
                        user => logstash
                        password => logstash
                      }
    }
    else if [type] == "endpoint-input"  {
        if [event_type] =~ "^PROCESS_*" {
            elasticsearch { hosts => ["172.238.238.239:9200"]
                            manage_template => true
                            template => "/opt/mapping/process_mapping.json"
                            template_name => "ep_process"
                            template_overwrite => true
                            index => "ep_process-%{[@metadata][index_day]}"
                            document_type => "_doc"
                            user => logstash
                            password => logstash
            }
        }
        else if [event_type] =~ "^DLP_*" or
            [event_type] in ["PASTEBOARD_CHANGE", "AIRDROP_FILE", "BLUETOOTH_FILE", "NFS_FILE", "PRINT", "SCREENCAPTURE", "USB_FILE", "AGENT_QUIT"]
        {
            elasticsearch { hosts => ["172.238.238.239:9200"]
                            manage_template => true
                            template => "/opt/mapping/dlp_mapping.json"
                            template_name => "ep_dlp"
                            template_overwrite => true
                            index => "ep_dlp-%{[@metadata][index_day]}"
                            document_type => "_doc"
                            user => logstash
                            password => logstash
            }
        }
        else if [event_type] =~ "^SYSTEM_*" {
            elasticsearch { hosts => ["172.238.238.239:9200"]
                            manage_template => true
                            template => "/opt/mapping/system_mapping.json"
                            template_name => "ep_system"
                            template_overwrite => true
                            index => "ep_system-%{[@metadata][index_day]}"
                            document_type => "_doc"
                            user => logstash
                            password => logstash
            }
        }
        else if [event_type] == "ENDPOINT_SYSTEM_LOG" {
            elasticsearch { hosts => ["172.238.238.239:9200"]
                            manage_template => true
                            template => "/opt/mapping/systemlog_mapping.json"
                            template_name => "ep_systemlog"
                            template_overwrite => true
                            index => "ep_systemlog-%{[@metadata][index_day]}"
                            document_type => "_doc"
                            user => logstash
                            password => logstash
            }
        }
        else {
            elasticsearch { hosts => ["172.238.238.239:9200"]
                            manage_template => true
                            template => "/opt/mapping/endpoint_others_mapping.json"
                            template_name => "ep_others"
                            template_overwrite => true
                            index => "ep_others-%{[@metadata][index_day]}"
                            document_type => "_doc"
                            user => logstash
                            password => logstash
            }
        }
    } # endpoint-input
    else if [type] == "seg-input"  {
        elasticsearch { hosts => ["172.238.238.239:9200"]
                        manage_template => true
                        template => "/opt/mapping/seg_mapping.json"
                        template_name => "seg"
                        template_overwrite => true
                        #index => "seg-%{+YYYY.MM.dd}"
                        index => "seg-%{[@metadata][index_day]}"
                        document_type => "_doc"
                        user => logstash
                        password => logstash
                      }
    }
    else {
        elasticsearch { hosts => ["172.238.238.239:9200"]
                        index => "others-%{+YYYY.MM.dd}"
                        document_type => "_doc"
                        user => logstash
                        password => logstash
                      }
    }
}
